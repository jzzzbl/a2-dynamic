"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const react_native_1 = require("react-native");
const react_native_svg_1 = require("react-native-svg");
const react_native_reanimated_1 = __importDefault(require("react-native-reanimated"));
const { add, sub, multiply, divide, cos, sin, lessOrEq, cond, concat, min, and, } = react_native_reanimated_1.default;
const AnimatedG = react_native_reanimated_1.default.createAnimatedComponent(react_native_svg_1.G);
const AnimatedPath = react_native_reanimated_1.default.createAnimatedComponent(react_native_svg_1.Path);
exports.defaultProps = {
    color: 'black',
    rotation: 0,
    lineCap: 'round',
    arcSweepAngle: 360,
    hideSmallAngle: true,
};
class AnimatedArc extends React.PureComponent {
    constructor() {
        super(...arguments);
        this.outerRadius = this.props.diameter / 2;
        this.innerRadius = this.props.diameter / 2 - this.props.width / 2;
        this.arcEndPosition = {
            x: new react_native_reanimated_1.default.Value(0),
            y: new react_native_reanimated_1.default.Value(0),
        };
        this.circlePath = this.getCirclePath(this.outerRadius, this.outerRadius, this.innerRadius, 0, min(this.props.arcSweepAngle, 360));
        this.rotation = concat(this.props.rotation, 'deg');
    }
    animatedString(strings, ...values) {
        const arr = [];
        const n = values.length;
        for (let i = 0; i < n; i++) {
            arr.push(strings[i], values[i]);
        }
        const end = strings[n];
        if (end) {
            arr.push(end);
        }
        return concat(...arr);
    }
    polarToCartesian(centerX, centerY, radius, angleInDegrees) {
        const angleInRadians = divide(multiply(sub(angleInDegrees, 90), Math.PI), 180);
        return {
            x: add(centerX, multiply(radius, cos(angleInRadians))),
            y: add(centerY, multiply(radius, sin(angleInRadians))),
        };
    }
    getCirclePath(x, y, radius, startAngle, endAngle) {
        const start = this.polarToCartesian(x, y, radius, multiply(endAngle, 0.9999));
        this.arcEndPosition = start;
        const hideSmallAngle = cond(and(this.props.hideSmallAngle ? 1 : 0, lessOrEq(sub(endAngle, startAngle), 1)), 1, 0);
        const end = this.polarToCartesian(x, y, radius, startAngle);
        const largeArcFlag = cond(lessOrEq(sub(endAngle, startAngle), 180), '0', '1');
        return cond(hideSmallAngle, '', this.animatedString `M ${start.x} ${start.y} A ${radius} ${radius} 0 ${largeArcFlag} 0 ${end.x} ${end.y}`);
    }
    render() {
        const { diameter, width, color, style, lineCap } = this.props;
        const offsetAndroid = react_native_1.Platform.OS === 'android' ? this.outerRadius : 0;
        const pivot = this.outerRadius;
        return (<react_native_1.View style={style}>
        <react_native_svg_1.Svg width={diameter} height={diameter} viewBox={`${-pivot} ${-pivot} ${diameter} ${diameter}`}>
          <AnimatedG style={{
            transform: [
                { translateX: -offsetAndroid },
                { rotate: this.rotation },
                { translateX: offsetAndroid },
            ],
        }}>
            <AnimatedPath d={this.circlePath} stroke={color} strokeWidth={width} strokeLinecap={lineCap} fill="transparent" transform={`translate(${-pivot} ${-pivot})`}/>
          </AnimatedG>
        </react_native_svg_1.Svg>
      </react_native_1.View>);
    }
}
exports.default = AnimatedArc;
AnimatedArc.defaultProps = exports.defaultProps;
//# sourceMappingURL=ReanimatedArcBase.js.map